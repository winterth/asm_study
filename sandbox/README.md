#汇编学习笔记

###GDB
单步调试: ni/si

查看寄存器内容: info reg

###通用寄存器
eax, ebx, ecx, edx
```
                 EAX
+--------+--------+--------+--------+
|        |        |        |        |
+--------+--------+--------+--------+
^                 ^   AH   ^   AL   ^
                          AX
```
#####复值指令：
######mov
```
mov eax, 1234H
```
dst和src的长度必需一致
```
mov eax, bx   <-- error
mov eax, ebx  <-- OK
```
`mov`可以将数据直接送入寄存器，也可以将一个寄存器的值送入另一个寄存器。但是不能将一个数据直接送入`段寄存器`。

######add
```
add ax, 10H
```
相当于 `ax=ax+10H`

######sub
```
sub ax, 10H
```
相当于 `ax=ax-10H`

###执行下一条指令
```
CS:IP
```
CS的值左移4位 + IP的值 ＝ 下一条指令在内存中的地址
修改下一条指令的地址有2种方法：

1. 自动。执行完一条后，IP的值会自动加上当前指令的长度
2. 用`jmp`跳转

	```
	jmp 100H       <-- 在当前段中跳转到100H的地方
	jmp 2000H:10H  <-- 直接跳转到指定的地址，即200010H
	```

###栈
`SS:SP`指向栈顶。如果栈为空，则SP指向栈的范围+1。
例如，栈的范围是1000:0 ~ 1000:1F，当栈为空时，SS:SP为`1000:20`
栈顶指针从高地址往低地址走。
例如，`push`2个字节后，SS:SP的值是`1000:1C`。
`push`和`pop`分都2步走：

1. 修改SP的地址
2. 送出/入相应的值。

`push`和`pop`不会修改`SS`的值，仅仅修改`SP`。并且，CPU不会保证`push`和`pop`的操作不越界，这需要程序员自己保证。
`SS`和`SP`的值可以用`mov`赋。这点跟`CS`、`IP`不一样。

###DS
`DS`寄存器用于存放要访问的数据的段地址。
由于`mov`不能将一个数据直接送入`段寄存器`，要给`DS`赋值，必需走曲线：

```
mov ax, 1000H
mov ds, ax
```

上面的`SS`也与`DS`一样。而`SP`则可以直接用数字赋值。

`[]`表示当前要访问数据的偏移地址。如果`DS = 1000H`，则`[1]`表示`10001H`，即`1000:1H`。
